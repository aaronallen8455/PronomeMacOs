// This file has been autogenerated from a class added in the UI designer.

using System;

using Foundation;
using AppKit;
using System.Collections.Generic;
using System.Linq;

namespace Pronome.Mac
{
    public partial class QuantizedTapController : NSViewController
    {
        #region Computed Fields
        private string _quantizationIntervalString;
        [Export("QuantizationIntervalString")]
        public string QuantizationIntervalString
        {
            get => _quantizationIntervalString;
            set
            {
                WillChangeValue("QuantizationIntervalString");
                // break into chunks
                string[] chunks = value.Split(',');

                bool isValid = true;

                LinkedList<double> newIntervals = new LinkedList<double>();
                // check that each value is valid
                foreach (string chunk in chunks)
                {
                    if (BeatCell.TryParse(chunk, out double val))
                    {
                        newIntervals.AddLast(val);
                    }
                    else
                    {
                        isValid = false;
                        break;
                    }
                }

                if (isValid)
                {
                    // every value is valid
                    QuantizeIntervals = newIntervals;
                    _quantizationIntervalString = value;
                }

                DidChangeValue("QuantizationIntervalString");
            }
        }

        private Layer _layer;
        [Export("Layer")]
        public Layer Layer
        {
            get => _layer;
            set
            {
                WillChangeValue("Layer");
                _layer = value;
                DidChangeValue("Layer");
            }
        }

        private NSMutableArray<Layer> _layerArray;
        [Export("layerArray")]
        public NSMutableArray LayerArray
        {
            get => _layerArray;
        }

        [Export("Metronome")]
        public Metronome Met
        {
            get => Metronome.Instance;
        }

        private bool _isListening = false;
        [Export("IsListening")]
        public bool IsListening
        {
            get => _isListening;
            set
            {
                WillChangeValue("IsListening");
                _isListening = value;
                DidChangeValue("IsListening");
            }
        }
        #endregion

        #region Public fields
        public NSViewController Presentor;
        #endregion

        #region Protected Variables
        /// <summary>
        /// The BPM position of each tap captured
        /// </summary>
        protected LinkedList<double> Taps = new LinkedList<double>();

        // TODO: should be a user setting
        /// <summary>
        /// The intervals to check against when quantizing
        /// </summary>
        protected LinkedList<double> QuantizeIntervals = new LinkedList<double>();
        #endregion

        #region Constructor
        public QuantizedTapController(IntPtr handle) : base(handle)
        {
            _layerArray = new NSMutableArray<Layer>(Metronome.Instance.Layers.ToArray());
        }
        #endregion

        #region Overridden Methods
        partial void BeginAction(NSObject sender)
        {
            IsListening = true;
            // lose focus for any inputs
            View.Window.MakeFirstResponder(null);

            // start playing the beat if it isn't already (plus count-down)
            if (Metronome.Instance.PlayState == Metronome.PlayStates.Playing)
            {

            }
            else if (CountOffCheckBox.State == NSCellStateValue.On)
            {
                // do count-off
            }
            else
            {
                TransportViewController.Instance.Play();
            }
        }

        // if started listening when already playing,
        // find modulo of tapped entry length against
        // elapsed time of first tap
        // we use this to find the first part,
        // which will be a portion of the tap cycle
        // that may involve an offset

        partial void DoneAction(NSObject sender)
        {
            if (Taps.Count <= 1 && QuantizeIntervals.Count > 0) return;  // need at least 2 to define a cell


            LinkedList<double> cellDurs = new LinkedList<double>();
            double last = 0;
            // get the quantized values
            foreach (double t in Taps.Select(x => Quantize(x)))
            {
                if (t == last) continue;
                cellDurs.AddLast(t - last);
                last = t;
            }

            // determine offset
            double length = last - cellDurs.First.Value;
            long cycles = (long)(cellDurs.First.Value / length);

            cellDurs.First.Value -= length * cycles;

            // rotate to the actual orientation
            double offset = cellDurs.First.Value;
            cellDurs.RemoveFirst();

            while (offset >= cellDurs.Last.Value)
            {
                offset -= cellDurs.Last.Value;
                // rotate
                cellDurs.AddFirst(cellDurs.Last.Value);
                cellDurs.RemoveLast();
            }

            // modify the layer
            string beatCode = string.Join(",", cellDurs.Select(x => x.ToString()));

            Layer.SetBeatCode(beatCode, offset.ToString());

            IsListening = false;

            Presentor.DismissViewController(this);
        }

        /// <summary>
        /// The tap action. triggered by a key bind to a button that is positioned off screen.
        /// </summary>
        /// <param name="sender">Sender.</param>
        partial void TapAction(NSObject sender)
        {
            if (IsListening)
            {
                Taps.AddLast(Metronome.Instance.ElapsedBpm);
            }
        }
        #endregion

        #region Protected Methods
        protected double Quantize(double value)
        {
            var qs = QuantizeIntervals
                .SelectMany(x => { int div = (int)(value / x); return new double[] { div * x, (div + 1) * x }; });
            //.Min(x => Math.Abs(value - x));

            double r = 0;
            double diff = double.MaxValue;

            // find match with minimal difference
            foreach (double q in qs)
            {
                double d = Math.Abs(value - q);
                if (d < diff)
                {
                    r = q;
                    diff = d;
                }
            }

            return r;
        }
        #endregion
    }
}
