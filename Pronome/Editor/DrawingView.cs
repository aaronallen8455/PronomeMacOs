// This file has been autogenerated from a class added in the UI designer.

using System;

using Foundation;
using AppKit;
using Pronome.Mac.Editor;
using System.Collections.Generic;
using CoreGraphics;
using Pronome.Mac.Editor.Groups;
using System.Linq;

namespace Pronome.Mac
{
    public partial class DrawingView : NSView
    {
        static public DrawingView Instance;

        const int RowHeight = 50;
        const int RowSpacing = 20;
        const int CellThickness = 5;

        /// <summary>
        /// Space between the bottom of top of cells and the row bounds.
        /// </summary>
        const int CellHeightPad = 10;

        static CGColor CellColor = NSColor.Black.CGColor;
        static CGColor SelectedCellColor = NSColor.Purple.CGColor;

        #region Public fields
        public Row[] Rows;
        #endregion

        #region Protected fields
        protected Queue<Row> RowsToDraw = new Queue<Row>();

        /// <summary>
        /// Used to convert BPM to pixels
        /// </summary>
        protected double ScalingFactor = 20;
        #endregion

        public DrawingView(IntPtr handle) : base(handle)
        {
            Instance = this;
            // instantiate the rows
            Rows = Metronome.Instance.Layers.Select(x => new Row(x)).ToArray();
        }

        #region Overrides
        public override void MouseDown(NSEvent theEvent)
        {
            base.MouseDown(theEvent);

            QueueAllRowsToDraw();
            //SetNeedsDisplayInRect();
        }

        public override void DrawRect(CGRect dirtyRect)
        {
            base.DrawRect(dirtyRect);

			using (CGContext ctx = NSGraphicsContext.CurrentContext.CGContext)
			{                   
                while (RowsToDraw.TryDequeue(out Row row))
                {
    					DrawRow(row, ctx);
                }
			}
        }

        public override void ViewDidMoveToWindow()
        {
            base.ViewDidMoveToWindow();

            //QueueAllRowsToDraw();
        }
        #endregion

        #region Protected Methods
        /// <summary>
        /// Queues all rows to draw.
        /// </summary>
        protected void QueueAllRowsToDraw()
        {
            foreach(Row row in Rows)
            {
                QueueRowToDraw(row);
            }
        }

        /// <summary>
        /// Queues the row to draw.
        /// </summary>
        /// <param name="row">Row.</param>
        protected void QueueRowToDraw(Row row)
        {
            //RowsToDraw.Clear();

            // see if there are any layers referencing this one.

            RowsToDraw.Enqueue(row);

            foreach (Row r in RowsToDraw)
            {
                int ind = r.Index;
                int y = GetYPositionOfRow(row);
                CGRect dirty = new CGRect(0, y, Frame.Width, RowHeight);
                SetNeedsDisplayInRect(dirty);
            }
        }

        /// <summary>
        /// Draws the specific row.
        /// </summary>
        /// <param name="row">Row.</param>
        /// <param name="baseCtx">Base context.</param>
        protected void DrawRow(Row row, CGContext baseCtx)
        {
			// get rect for the CGLayer to use
			int y = GetYPositionOfRow(row);
            int x = (int)(row.Offset * ScalingFactor);
            int width = (int)(row.Duration * ScalingFactor);

            using (CGLayer layer = CGLayer.Create(baseCtx, new CGSize(width, RowHeight)))
            {
                CGContext layerCtx = layer.Context;

                // these stacks facilitate the drawing of repeat groups.
                Stack<Repeat> ActiveRepeats = new Stack<Repeat>();
                Stack<CGLayer> RepeatLayers = new Stack<CGLayer>();

                Stack<Multiply> ActiveMults = new Stack<Multiply>();

                foreach (Cell cell in row.Cells)
                {
                    CGContext ctx = HandleRepeatGroups(layerCtx, ActiveRepeats, RepeatLayers, cell);

                    HandleMultGroups(ActiveMults, cell, ctx);

                    if (!string.IsNullOrEmpty(cell.Reference))
                    {
                        DrawReferenceRect(cell, ctx);

                        continue;
                    }

                    int xPos = (int)(cell.Position * ScalingFactor);
                    ctx.MoveTo(xPos, CellHeightPad);

                    if (cell.IsSelected) ctx.SetFillColor(SelectedCellColor);
                    else ctx.SetFillColor(CellColor);

                    ctx.FillRect(new CGRect(xPos, CellHeightPad, CellThickness, RowHeight - CellHeightPad));
				}

                int pos = (int)(row.Offset * ScalingFactor);
                int length = (int)(row.Duration * ScalingFactor);
                //int ypos = GetYPositionOfRow(row);

                // draw actual elements
                baseCtx.DrawLayer(layer, new CGPoint(pos, y));
                pos += length;

                // draw ghosts
                baseCtx.SetAlpha(.5f);
                while (pos < Frame.Width)
                {
                    baseCtx.DrawLayer(layer, new CGPoint(pos, y));
                    pos += length;
                }
                baseCtx.SetAlpha(1);

                // draw grid lines if there's a selection
            }
        }

        protected CGContext HandleRepeatGroups(CGContext layerCtx, Stack<Repeat> ActiveRepeats, Stack<CGLayer> RepeatLayers, Cell cell)
        {
            if (!ActiveRepeats.Any()) return layerCtx;
            // check if repeat groups are ended
            Repeat repGroup = ActiveRepeats.Peek();

            while (repGroup != null && !cell.RepeatGroups.Contains(repGroup))
            {
                ActiveRepeats.Pop();
                var replyer = RepeatLayers.Pop();
                // get the context to draw on
                var c = RepeatLayers.Peek()?.Context ?? layerCtx;
                // draw originals
                int dur = (int)(repGroup.Length * ScalingFactor);
                int xp = (int)(repGroup.Position * ScalingFactor);
                c.DrawLayer(replyer, new CGPoint(xp, 0));
                // draw copies
                c.SetAlpha(.7f); // repeats are faded
                for (int i = 1; i < repGroup.Times; i++)
                {
                    c.DrawLayer(replyer, new CGPoint(xp + dur * i, 0));
                }
                c.SetAlpha(1f);

                replyer.Dispose();

                repGroup = ActiveRepeats.Peek();
            }

            // update to current context
            CGContext ctx = RepeatLayers.Peek()?.Context ?? layerCtx;

            // check if repeat groups are opened
            if (ActiveRepeats.Peek() != cell.RepeatGroups.Last?.Value)
            {
                LinkedListNode<Repeat> cellGroup = cell.RepeatGroups.Last;
                // find the group that is currently open
                while (cellGroup?.Value != ActiveRepeats.Peek())
                {
                    cellGroup = cellGroup.Previous;
                }
                // add all new groups
                while (cellGroup != null)
                {
                    var gp = cellGroup.Value;
                    ActiveRepeats.Push(gp);
                    int w = (int)(gp.Length * ScalingFactor);
                    RepeatLayers.Push(CGLayer.Create(ctx, new CGSize(w, RowHeight)));

                    // draw the element
                    DrawGroupElement(ctx, NSColor.Green.CGColor, gp);

                    ctx = RepeatLayers.Peek().Context;

                    cellGroup = cellGroup.Next;
                }
            }

            return ctx;
        }

        /// <summary>
        /// Add / remove groups from the stack, draw any new groups.
        /// </summary>
        /// <param name="ActiveMults">Active mults.</param>
        /// <param name="cell">Cell.</param>
        /// <param name="ctx">Context.</param>
        protected void HandleMultGroups(Stack<Multiply> ActiveMults, Cell cell, CGContext ctx)
        {
            if (!ActiveMults.Any()) return;

            Multiply multGroup = ActiveMults.Peek();
            // check if a mult groups are closed
            while (multGroup != null && !cell.MultGroups.Contains(multGroup))
            {
                ActiveMults.Pop();
                multGroup = ActiveMults.Peek();
            }

            // check if mult groups are opened
            LinkedListNode<Multiply> cellMGrp = cell.MultGroups.Last;
            if (ActiveMults.Peek() != cellMGrp?.Value)
            {
                // descend to currently active group
                while (ActiveMults.Peek() != cellMGrp?.Value)
                {
                    cellMGrp = cellMGrp.Previous;
                }

                while (cellMGrp != null)
                {
                    var mg = cellMGrp.Value;
                    ActiveMults.Push(mg);

                    // draw the element
                    DrawGroupElement(ctx, NSColor.Orange.CGColor, mg);

                    cellMGrp = cellMGrp.Next;
                }
            }
        }

        /// <summary>
        /// Draws the rectangle that signifies a layer reference.
        /// </summary>
        /// <param name="cell">Cell.</param>
        /// <param name="ctx">Context.</param>
        protected void DrawReferenceRect(Cell cell, CGContext ctx)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Draws a group box with the specified attributes.
        /// </summary>
        /// <param name="ctx">Context.</param>
        /// <param name="color">Color.</param>
        /// <param name="group">Group.</param>
        /// <param name="pad">Pad.</param>
        protected void DrawGroupElement(CGContext ctx, CGColor color, AbstractGroup group, int pad = 0)
        {
            var clear = new CGColor(color, 0);

			var gradient = new CGGradient(
				CGColorSpace.CreateDeviceRGB(),
				new CGColor[] { color, clear, clear, color },
				new nfloat[] { 0, .1f, .9f, 1 }
			);

            var start = new CGPoint(group.Position * ScalingFactor, pad);
            var end = new CGPoint(group.Position * ScalingFactor + group.Length * ScalingFactor, pad);

            ctx.SaveState();

            var rect = new CGRect(start, new CGSize(group.Length * ScalingFactor, RowHeight - pad / 2));
            ctx.AddRect(rect);

            ctx.Clip();

			ctx.DrawLinearGradient(
				gradient,
				start,
				end,
				CGGradientDrawingOptions.None
			);

            ctx.SetStrokeColor(color);
            ctx.AddRect(rect);
            ctx.StrokePath();

            ctx.RestoreState();
        }

        /// <summary>
        /// Gets the Y position of a row based on it's index.
        /// </summary>
        /// <returns>The YP osition of row.</returns>
        /// <param name="row">Row.</param>
        protected int GetYPositionOfRow(Row row)
        {
            return (int)(Frame.Height - RowHeight - RowSpacing - (RowHeight + RowSpacing) * row.Index);
		}
        #endregion
    }
}
