// This file has been autogenerated from a class added in the UI designer.

using System;

using Foundation;
using AppKit;
using Pronome.Mac.Editor;
using System.Collections.Generic;
using CoreGraphics;
using Pronome.Mac.Editor.Groups;
using System.Linq;
using CoreAnimation;
using Pronome.Mac.Editor.Action;

namespace Pronome.Mac
{
    public partial class DrawingView : NSView
    {
        #region Static fields
        static public DrawingView Instance;

		/// <summary>
		/// Used to convert BPM to pixels
		/// </summary>
		static public float ScalingFactor = 60;

        const float BaseFactor = 60;
        #endregion

        #region Constants
        const int RowHeight = 50;
        const int RowSpacing = 20;
        public const int CellWidth = 4; // pixel width of cell elements
        public const int PaddingLeft = 5; // distance from left of frame to the start of rows

        /// <summary>
        /// Space between the bottom of top of cells and the row bounds.
        /// </summary>
        const int CellHeightPad = 10;
        #endregion

        #region Colors
        static CGColor CellColor = NSColor.Black.CGColor;
        static CGColor SelectedCellColor = NSColor.Purple.CGColor;
        static CGColor RowBackgroundColor = NSColor.LightGray.CGColor;
        static CGColor SelectBoxColor = NSColor.DarkGray.CGColor;
        static CGColor GridLineColor = NSColor.Red.CGColor;
        static CGColor MeasureLineColor = NSColor.Blue.CGColor;
        static CGColor ReferenceRectColor = NSColor.Magenta.CGColor;
        static CGColor RepeatGroupColor = NSColor.Green.CGColor;
        static CGColor MultGroupColor = NSColor.Orange.CGColor;
        #endregion

        #region Computed Properties
        private string _cursorPostion;
        /// <summary>
        /// Used to display the mouse location in BPM
        /// </summary>
        /// <value>The cursor position.</value>
        [Export("CursorPosition")]
        public string CursorPosition
        {
            get => _cursorPostion;
            set
            {
                WillChangeValue("CursorPosition");
                _cursorPostion = value;
                DidChangeValue("CursorPosition");
            }
        }


        private string _gridSpacingString = "1";
        [Export("GridSpacingString")]
        public string GridSpacingString
        {
            get => _gridSpacingString;
            set
            {
                WillChangeValue("GridSpacingString");
                if (BeatCell.TryParse(value, out double bpm) && bpm > 0)
                {
                    GridSpacing = bpm;
					_gridSpacingString = value;

                    // draw selected row if one exists
                    if (SelectedCells.Root != null)
                    {
                        QueueRowToDraw(SelectedCells.Root.Cell.Row);
                    }
                }
                DidChangeValue("GridSpacingString");
            }
        }

        private string _measureSizeString = "4";
        [Export("MeasureSizeString")]
        public string MeasureSizeString
        {
            get => _measureSizeString;
            set
            {
                WillChangeValue("MeasureSizeString");
                if (BeatCell.TryParse(value, out double bpm) && bpm > 0)
                {
                    MeasureSize = bpm;
                    _measureSizeString = value;
                    // need to redraw the whole view
                    NeedsDisplay = true;
                }
                DidChangeValue("MeasureSizeString");
            }
        }

        /// <summary>
        /// Gets or sets the duration field.
        /// </summary>
        /// <value>The duration field.</value>
        [Export("Duration")]
        public string DurationField
        {
            get
            {
                if (SelectionExists)
                {
                    if (SelectedCells.Count == 1)
                    {
                        return SelectedCells.Root.Cell.Value;
                    }
                    else
                    {
                        // check if all selected have the same duration
                        double bpm = SelectedCells.Root.Cell.Duration;
                        foreach (Cell cell in SelectedCells)
                        {
                            if (bpm != cell.Duration)
                            {
                                bpm = -1;
                                break;
                            }
                        }
                        if (bpm > 0)
                        {
                            return SelectedCells.Root.Cell.Value;
                        }
                    }
                }

                return string.Empty;
            }
            set
            {
                WillChangeValue("Duration");
                if (BeatCell.TryParse(value, out double bpm))
                {
                    var action = new CellDuration(SelectedCells, value);

                    EditorViewController.InitNewAction(action);
                }
                DidChangeValue("Duration");
            }
        }

        [Export("SelectedSource")]
        public string SelectedSource
        {
            get
            {
                if (SelectionExists)
                {
                    // check if all selected have the same source
                    var src = SelectedCells.Root.Cell.Source;

                    foreach (Cell c in SelectedCells)
                    {
                        if (c.Source != src) return null;
                    }

                    if (src == null) return SelectedCells.Root.Cell.Row.Layer.BaseStreamInfo.ToString();
                    return src.ToString();
                }
                return null;
            }

            set
            {
                WillChangeValue("SelectedSource");
                WillChangeValue("PitchSource");

                StreamInfoProvider src = StreamInfoProvider.GetFromToString(value);

                foreach (Cell c in SelectedCells)
                {
                    if (c.Source != src)
                    {
                        ChangesApplied = false;
						c.Source = src;
                    }
                }

                SelectedCells.Root.Cell.Row.UpdateBeatCode();

                DidChangeValue("SelectedSource");
                DidChangeValue("PitchSource");
            }
        }

        [Export("PitchSource")]
        public string PitchSource
        {
            get
            {
                if (!string.IsNullOrEmpty(SelectedSource))
                {
                    var src = SelectedCells.Root.Cell.Source ?? SelectedCells.Root.Cell.Row.Layer.BaseStreamInfo;
                    if (src.IsPitch)
                    {
                        return src.Uri;
                    }
                }
                return null;
            }
            set
            {
                if (!string.IsNullOrEmpty(value))
                {
					WillChangeValue("PitchSource");
                    var src = StreamInfoProvider.GetFromPitch(value);

                    foreach (Cell c in SelectedCells)
                    {
                        c.Source = src;
                    }
					DidChangeValue("PitchSource");
                }
            }
        }


        /// <summary>
        /// True if a selection is made.
        /// </summary>
        /// <value><c>true</c> if selection exists; otherwise, <c>false</c>.</value>
        [Export("SelectionExists")]
        public bool SelectionExists
        {
            get => SelectedCells.Root != null;
        }

        string _zoom = "100%";
        [Export("Zoom")]
        public string Zoom
        {
            get => _zoom;
            set
            {
                WillChangeValue("Zoom");

                string trimmed = value.TrimEnd('%').TrimStart();
                if (float.TryParse(trimmed, out float num) && num > 0 && num < 5000)
                {
                    ScalingFactor = BaseFactor * (100 / num);

                    // redraw
                    NeedsDisplay = true;

                    _zoom = trimmed + "%";
                }

                DidChangeValue("Zoom");
            }
        }

        bool _changesApplied = true;
        [Export("ChangesApplied")]
        public bool ChangesApplied
        {
            get => _changesApplied;
            set
            {
                WillChangeValue("ChangesApplied");
                _changesApplied = value;
                DidChangeValue("ChangesApplied");
            }
        }
        #endregion

        #region Public fields
        public Row[] Rows;

        public CellTree SelectedCells = new CellTree();
        #endregion

        #region Protected fields
        protected Queue<Row> RowsToDraw = new Queue<Row>();

        /// <summary>
        /// Used to determine which direction to collapse a selection (using shift key)
        /// </summary>
        protected CellTreeNode SelectionAnchor;

        private CGPoint SelectBoxOrigin = CGPoint.Empty;
        private CAShapeLayer SelectBox;
        private int SelectBoxUpperBound;
        private int SelectBoxLowerBound;
        private int _selectRowIndex;

        /// <summary>
        /// The spacing of the grid lines in BPM
        /// </summary>
        public double GridSpacing = 1;

        /// <summary>
        /// Spacing between measure lines in BPM
        /// </summary>
        protected double MeasureSize = 4;

        /// <summary>
        /// Holds the copied cells that can then be pasted
        /// </summary>
        protected LinkedList<Cell> ClipBoard;
        #endregion
        #region Constructor
        public DrawingView(IntPtr handle) : base(handle)
        {
            Instance = this;
            // if beat editor was being used when opened, apply changes by losing focus
			NSApplication.SharedApplication.MainWindow.MakeFirstResponder(null);

            InitRows(false); // don't need to draw here because view will redraw afterwards regardless
        }
        #endregion
        #region Public methods
        /// <summary>
        /// Builds the row objects from the current metronome state
        /// </summary>
        public void InitRows(bool queueDraw = true)
        {
			Rows = new Row[Metronome.Instance.Layers.Count];
			double maxDur = 0;
			for (int i = 0; i < Rows.Length; i++)
			{
				Rows[i] = new Row(Metronome.Instance.Layers[i]);
				if (Rows[i].Duration > maxDur) maxDur = Rows[i].Duration;
			}


            ResizeFrame(maxDur, queueDraw); // resize frame and draw all rows
			//NeedsDisplay = true;
		}

        /// <summary>
        /// Clears the current selection. Does not redraw rows.
        /// </summary>
        public void DeselectCells()
		{
            WillChangeValue("Duration");
            WillChangeValue("SelectionExists");
            WillChangeValue("SelectedSource");
            WillChangeValue("PitchSource");

			foreach (Cell c in SelectedCells)
			{
				c.IsSelected = false;
			}

			SelectedCells.Clear();
			SelectionAnchor = null;

            DidChangeValue("Duration");
            DidChangeValue("SelectionExists");
            DidChangeValue("SelectedSource");
            DidChangeValue("PitchSource");
		}

        /// <summary>
        /// Resizes the frame to match the given BPM length, then draw all rows.
        /// </summary>
        /// <param name="bpmLength">Bpm length.</param>
        public void ResizeFrame(double bpmLength, bool queueDraw = true)
        {

            var frame = Frame;
            frame.Width = (nfloat)Math.Max(Superview.Bounds.Width, bpmLength * ScalingFactor + 550);
            frame.Height = (nfloat)Math.Max(Superview.Bounds.Height, (RowSpacing + RowHeight) * Rows.Length + RowSpacing);
            Frame = frame;
            if (queueDraw)
            {
				QueueAllRowsToDraw();
                //NeedsDisplay = true;
            }
        }

		/// <summary>
		/// Performs actions on cell selection based on a targeted cell.
		/// </summary>
		/// <param name="cell">Cell.</param>
		/// <param name="extendSelection">If set to <c>true</c> extend selection.</param>
		public void SelectCell(Cell cell, bool extendSelection = false)
		{
			WillChangeValue("Duration");
            WillChangeValue("SelectionExists");
            WillChangeValue("SelectedSource");
            WillChangeValue("PitchSource");

			// is there an existing selection?
			if (SelectedCells.Root != null)
			{
				// is current selection in same row?
				if (extendSelection && SelectedCells.Root.Cell.Row == cell.Row)
				{
					// extend or collapse the selection
					CellTreeNode min = SelectedCells.Min;
					CellTreeNode max = SelectedCells.Max;

					if (min.Cell == cell)
					{
						// clicked on a boundary cell
						if (SelectedCells.Count == 1)
						{
							DeselectCells();
						}
						else
						{
							SelectedCells.Remove(min);
							cell.IsSelected = false;

							if (SelectionAnchor == min)
							{
								SelectionAnchor = max;
							}
						}
					}
					else if (max.Cell == cell)
					{
						if (SelectedCells.Count == 1)
						{
							DeselectCells();
						}
						else
						{
							SelectedCells.Remove(max);
							cell.IsSelected = false;

							if (SelectionAnchor == max)
							{
								SelectionAnchor = min;
							}
						}
					}
					else if (cell.Position < min.Cell.Position)
					{
						SelectionAnchor = max;

						CellTreeNode node = cell.Row.Cells.Lookup(min.Cell.Position, false)?.Prev();
						// select cells down to the target
						while (node != null && node.Cell != cell)
						{
                            if (!node.Cell.IsReference)
                            {
								node.Cell.IsSelected = true;
								SelectedCells.Insert(node.Cell);
                            }

							node = node.Prev();
						}

                        if (node != null && !node.Cell.IsReference)
						{
							node.Cell.IsSelected = true;
							SelectedCells.Insert(node.Cell);
						}
					}
					else if (cell.Position > max.Cell.Position)
					{
						SelectionAnchor = min;

						CellTreeNode node = cell.Row.Cells.Lookup(max.Cell.Position, false);
						// select cells up to the target
						while (node.Cell != cell)
						{
							node = node.Next();
                            if (!node.Cell.IsReference)
                            {
								node.Cell.IsSelected = true;
								SelectedCells.Insert(node.Cell);
                            }
						}
					}
					else
					{
						// collapsing selection
						if (SelectionAnchor == min)
						{
							CellTreeNode node = cell.Row.Cells.Lookup(max.Cell.Position, false);

							while (node.Cell != cell)
							{
                                if (!node.Cell.IsReference)
                                {
									node.Cell.IsSelected = false;
									SelectedCells.Remove(node.Cell);
                                }
								node = node.Prev();
							}
						}
						else
						{
							CellTreeNode node = cell.Row.Cells.Lookup(min.Cell.Position, false);

							while (node.Cell != cell)
							{
                                if (!node.Cell.IsReference)
                                {
									node.Cell.IsSelected = false;
									SelectedCells.Remove(node.Cell);
                                }
								node = node.Next();
							}
						}
					}
				}
				else
				{
					// clear and select target cell only
					if (SelectedCells.Root.Cell.Row != cell.Row)
					{
						QueueRowToDraw(SelectedCells.Root.Cell.Row);
					}

					DeselectCells();
					SelectCell(cell);
				}
			}
			else
			{
                // select a single cell
                if (!cell.IsReference)
                {
					cell.IsSelected = true;
					SelectionAnchor = new CellTreeNode(cell);
					SelectedCells.Insert(SelectionAnchor);
                }
			}

			DidChangeValue("Duration");
            DidChangeValue("SelectionExists");
            DidChangeValue("SelectedSource");
            DidChangeValue("PitchSource");
		}

		/// <summary>
		/// Deletes the selected cells, does not parse new beatcode (or referencers) or redraw.
		/// </summary>
		public void DeleteSelectedCells()
		{
			if (SelectionExists)
			{
				foreach (Cell cell in SelectedCells)
				{
					cell.Delete();
				}
		
				DeselectCells();
			}
		}

		/// <summary>
		/// Queues all rows to draw.
		/// </summary>
		public void QueueAllRowsToDraw()
		{
			foreach (Row row in Rows)
			{
				QueueRowToDraw(row);
			}
		}

		/// <summary>
		/// Queues the row to draw. Does not redraw referencers
		/// </summary>
		/// <param name="row">Row.</param>
		public void QueueRowToDraw(Row row)
		{
            if (RowsToDraw.Contains(row)) return;

			RowsToDraw.Enqueue(row);

			foreach (Row r in RowsToDraw)
			{
				int ind = r.Index;
				int y = GetYPositionOfRow(row);
				CGRect dirty = new CGRect(0, y, Frame.Width, RowHeight);
				SetNeedsDisplayInRect(dirty);
			}
		}
        #endregion

        #region Overrides

        /// <summary>
        /// Handles all mouse1 operations: selecting cells, creating new cells
        /// </summary>
        /// <param name="theEvent">The event.</param>
        public override void MouseDown(NSEvent theEvent)
        {
            base.MouseDown(theEvent);

            ClickHandler(theEvent);
        }

        public override void RightMouseDown(NSEvent theEvent)
        {
            base.RightMouseDown(theEvent);

            ClickHandler(theEvent, true);
        }

        public override void MouseDragged(NSEvent theEvent)
        {
            base.MouseDragged(theEvent);

            DragHandler(theEvent);
        }

        public override void RightMouseDragged(NSEvent theEvent)
        {
            base.RightMouseDragged(theEvent);

            DragHandler(theEvent);
        }

        public override void MouseUp(NSEvent theEvent)
        {
            base.MouseUp(theEvent);

            MouseUpHandler(theEvent);
        }

        public override void RightMouseUp(NSEvent theEvent)
        {
            base.RightMouseUp(theEvent);

            MouseUpHandler(theEvent);
        }

        public override void MouseMoved(NSEvent theEvent)
        {
            base.MouseMoved(theEvent);
            // display the current position in BPM
            double pos = (ConvertPointFromView(theEvent.LocationInWindow, null).X - PaddingLeft) / ScalingFactor;

            if (pos >= 0)
            {
                string measure = ((int)(pos / MeasureSize)).ToString();
                string position = (pos % MeasureSize).ToString("F2");

                CursorPosition = measure + " : " + position;
            }
            else
            {
                CursorPosition = string.Empty;
            }
        }

        public override void MouseEntered(NSEvent theEvent)
        {
            base.MouseEntered(theEvent);

            Window.AcceptsMouseMovedEvents = true;
            Window.MakeFirstResponder(this);
        }

        public override void MouseExited(NSEvent theEvent)
        {
            base.MouseExited(theEvent);

            Window.AcceptsMouseMovedEvents = false;
            CursorPosition = string.Empty;
        }

        /// <summary>
        /// Render the rows in the queue.
        /// </summary>
        /// <param name="dirtyRect">Dirty rect.</param>
        public override void DrawRect(CGRect dirtyRect)
        {
            base.DrawRect(dirtyRect);

			using (CGContext ctx = NSGraphicsContext.CurrentContext.CGContext)
            {
                DrawMeasureLines(ctx);

                if (!RowsToDraw.Any())
                {
                    // draw all rows if initializing or changing window size.
                    foreach (Row row in Rows)
                    {
                        DrawRow(row, ctx);
                    }
                }
                else
                {
                    // draw just the rows in the queue
                    while (RowsToDraw.TryDequeue(out Row row))
                    {
                        DrawRow(row, ctx);
                    }
                }

                // draw grid lines if there's a selection
                if (SelectedCells.Root != null)
                {
                    DrawGridLines(ctx);
                }
            }
        }

        private void DrawMeasureLines(CGContext ctx)
        {
            // draw measure lines
            ctx.SetStrokeColor(MeasureLineColor);
            ctx.SetLineWidth(1);
            double xPos = PaddingLeft;
            ctx.MoveTo((int)xPos, 0);
            double spacing = MeasureSize * ScalingFactor;
            while (xPos <= Frame.Width)
            {
                int x = (int)xPos;
                ctx.MoveTo(x, 0);

                ctx.AddLineToPoint(x, Frame.Height);

                xPos += spacing;
            }
            ctx.StrokePath();
        }

        public override void ViewDidMoveToWindow()
        {
            base.ViewDidMoveToWindow();
            // scroll to top because default is at bottom
            ScrollPoint(new CGPoint(0, Bounds.Height));
            // add the tracking area, for mouse move events
            AddTrackingRect(Frame, this, IntPtr.Zero, false);
        }

        [Action("copy:")]
		public void CopyAction(NSObject sender)
		{
            ClipBoard = new LinkedList<Cell>();
            //ClipBoard = SelectedCells.ToArray().Where(x => !x.IsReference).ToArray();
            Row selectedRow = SelectedCells.Root.Cell.Row;
            var firstSelected = SelectedCells.Min.Cell;
            var lastSelected = SelectedCells.Max.Cell;
			// original is key, copy is value
			Dictionary<Repeat, Repeat> CopiedRepeatGroups = new Dictionary<Repeat, Repeat>();
            Dictionary<Multiply, Multiply> CopiedMultGroups = new Dictionary<Multiply, Multiply>();

            foreach (Cell c in SelectedCells.ToArray().Where(x => !x.IsReference))
            {
                Cell copy = new Cell(c.Row)
                {
                    Value = c.Value,
                    Source = c.Source,
                    Reference = c.Reference,
                    IsBreak = c.IsBreak,
                    Position = c.Position
                };

				// if this is the first cell and is the first cell of a rep group or mult group, copy those groups
				foreach (Repeat rg in c.RepeatGroups)
				{
					Repeat rgCopy = null;
					if (CopiedRepeatGroups.ContainsKey(rg))
					{
						rgCopy = CopiedRepeatGroups[rg];
					}
					else if (rg.Cells.First.Value == c
                             && (!lastSelected.RepeatGroups.Contains(rg)
                                 || rg.Cells.Last.Value == lastSelected))
					{
                        rgCopy = new Repeat()
                        {
                            Times = rg.Times,
                            LastTermModifier = rg.LastTermModifier,
                        };
						CopiedRepeatGroups.Add(rg, rgCopy);
					}

					if (rgCopy != null)
					{
						rgCopy.Cells.AddLast(copy);
						copy.RepeatGroups.AddLast(rgCopy);
					}
				}

                foreach (Multiply mg in c.MultGroups)
				{
                    Multiply mgCopy = null;
					if (CopiedMultGroups.ContainsKey(mg))
					{
						mgCopy = CopiedMultGroups[mg];
					}
					else if (mg.Cells.First.Value == c
                             && (!lastSelected.MultGroups.Contains(mg)
                                 || mg.Cells.Last.Value == lastSelected))
					{
                        mgCopy = new Multiply();
						mgCopy.FactorValue = mg.FactorValue;
						CopiedMultGroups.Add(mg, mgCopy);
					}

					if (mgCopy != null)
					{
						mgCopy.Cells.AddLast(copy);
						copy.MultGroups.AddLast(mgCopy);
					}
				}

                ClipBoard.AddLast(copy);
            }
		}

        [Action("cut:")]
        public void CutAction(NSObject sender)
        {
            CopyAction(sender);

            // delete cells
            Row selectedRow = SelectedCells.Root.Cell.Row;

            var action = new RemoveCells(SelectedCells);

            EditorViewController.InitNewAction(action);
            //DeleteSelectedCells();
            //selectedRow.Redraw();
            //QueueRowToDraw(selectedRow);
            //// handle referencers
            //if (Row.ReferenceMap.ContainsKey(selectedRow.Index))
            //{
			//	foreach (int index in Row.ReferenceMap[selectedRow.Index])
			//	{
			//		Rows[index].Redraw();
			//		QueueRowToDraw(Rows[index]);
			//	}
            //}
        }

        /// <summary>
        /// Paste the cells in the clipboard over the currently selected ones
        /// </summary>
        /// <param name="sender">Sender.</param>
        [Action("paste:")]
        public void PasteAction(NSObject sender)
        {
            var action = new PasteCells(ClipBoard, SelectedCells);

            EditorViewController.InitNewAction(action);
        }

        /// <summary>
        /// Check if copy/cut/paste is valid
        /// </summary>
        /// <returns><c>true</c>, if menu action was validated, <c>false</c> otherwise.</returns>
        /// <param name="item">Item.</param>
        [Action("validateMenuItem:")]
        public bool ValidateMenuAction(NSMenuItem item)
        {
            string actionName = item.Action.Name;

            if (actionName == "cut:" || actionName == "copy:")
            {
                return SelectionExists;
            }
            else if (actionName == "paste:")
            {
                return SelectionExists && ClipBoard != null;
            }

            return true;
        }

		#endregion

		#region Protected Methods

        /// <summary>
        /// Check what elements are under the select box and perform necessary actions.
        /// </summary>
        /// <param name="theEvent">The event.</param>
		private void MouseUpHandler(NSEvent theEvent)
		{
			if (!SelectBoxOrigin.IsEmpty)
			{
				// handle selection
				var loc = ConvertPointFromView(theEvent.LocationInWindow, null);
				double start = ConvertPixelsToBpm(Math.Min(SelectBoxOrigin.X, loc.X), Rows[_selectRowIndex]);
				double end = ConvertPixelsToBpm(Math.Max(SelectBoxOrigin.X, loc.X), Rows[_selectRowIndex]);

				// check if extending current selection
				bool shift = theEvent.ModifierFlags.HasFlag(NSEventModifierMask.ShiftKeyMask);

				var startNode = Rows[_selectRowIndex].Cells.FindAboveOrEqualTo(start, true);
				var endNode = Rows[_selectRowIndex].Cells.FindBelowOrEqualTo(end);

				if (startNode != null && startNode.Cell.Position <= endNode.Cell.Position)
				{
					// perform selection
					SelectCell(startNode.Cell, shift);

					if (startNode != endNode)
					{
						SelectCell(endNode.Cell, true);
					}

					QueueRowToDraw(Rows[_selectRowIndex]);
				}
                else if (!shift && SelectedCells.Root != null)
				{
					QueueRowToDraw(SelectedCells.Root.Cell.Row);

                    DeselectCells();
				}


				SelectBox.RemoveFromSuperLayer();
				SelectBox.Dispose();
				SelectBoxOrigin = CGPoint.Empty;
			}
		}

        /// <summary>
        /// Resize the select box
        /// </summary>
        /// <param name="theEvent">The event.</param>
		private void DragHandler(NSEvent theEvent)
		{
            // continue to print coordinates
            MouseMoved(theEvent);
            
			if (!SelectBoxOrigin.IsEmpty)
			{
				var loc = ConvertPointFromView(theEvent.LocationInWindow, null);

				using (CGPath path = new CGPath())
				{
					nfloat y = loc.Y;
					if (y > SelectBoxUpperBound)
					{
						y = SelectBoxUpperBound;
					}
					else if (y < SelectBoxLowerBound)
					{
						y = SelectBoxLowerBound;
					}

					loc.Y = y;

					path.MoveToPoint(SelectBoxOrigin);
					path.AddLineToPoint(SelectBoxOrigin.X, y);
					path.AddLineToPoint(loc);
					path.AddLineToPoint(loc.X, SelectBoxOrigin.Y);
					path.CloseSubpath();

					SelectBox.Path = path;
				}
			}
		}

        /// <summary>
        /// Check if an element was clicked or select box drawn and do selection action
        /// </summary>
        /// <param name="theEvent">The event.</param>
        /// <param name="isRightButton">If set to <c>true</c> is right button.</param>
		private void ClickHandler(NSEvent theEvent, bool isRightButton = false)
		{
            // don't allow editing while a sheet is open
            if (EditorViewController.Instance.SheetIsOpen) return;

			// get coordinates of mouse
			var loc = ConvertPointFromView(theEvent.LocationInWindow, null);

			// determine which row was clicked in
			int offset = (int)(Frame.Height - loc.Y - RowSpacing);
			int rowIndex = offset / (RowSpacing + RowHeight);

			// see if it's inside the row (not in spacing)
			if (rowIndex < Rows.Length)
			{
				var ypos = GetYPositionOfRow(Rows[rowIndex]);

				// check if a selection is being drawn
				if (theEvent.ModifierFlags.HasFlag(NSEventModifierMask.ControlKeyMask) || isRightButton)
				{
					if (loc.Y >= ypos && loc.Y <= ypos + RowHeight)
					{
						_selectRowIndex = rowIndex;
						InitSelectBox(loc, ypos + RowHeight, ypos);
						return;
					}
				}

				// see if click is in y range
				if (!isRightButton && loc.Y >= ypos && loc.Y <= ypos + RowHeight)
				{
                    Row row = Rows[rowIndex];
                    double xPos = ConvertPixelsToBpm(loc.X, row);

                    // cell range
                    if (loc.Y >= ypos + CellHeightPad && loc.Y <= ypos + RowHeight - CellHeightPad)
                    {
                        // see if a reference is being selected
                        var reference = row.ReferencePositionAndDurations.Where(p => p.position <= xPos && xPos < p.position + p.duration);

                        if (reference.Any())
						{
                            (double pos, double dur) = reference.FirstOrDefault();
                            Cell rcell = row.Cells.Lookup(pos, false).Cell;
                            SelectCell(rcell, theEvent.ModifierFlags.HasFlag(NSEventModifierMask.ShiftKeyMask));
                            QueueRowToDraw(row);
                            return;
						}

                        if (row.Cells.TryFind(xPos, out Cell cell))
                        {
                            // perform selection actions
                            SelectCell(cell, theEvent.ModifierFlags.HasFlag(NSEventModifierMask.ShiftKeyMask));
                            QueueRowToDraw(row);
                            return;
                        }
                    }

					// check if a cell was clicked
					if (SelectedCells.Root != null)
					{
                        // try to create new cell
                        // see if clicked on a grid line (within a pad amount)

                        //double end = ConvertBpmToPixels(SelectedCells.GetMax().Cell.Position, row);
                        double end = SelectedCells.Max.Cell.Position;
                        double start = SelectedCells.Min.Cell.Position;

                        // get selection bounds within the row's cells
                        CellTreeNode endNode = row.Cells.Lookup(end);
                        CellTreeNode startNode = row.Cells.Lookup(start);

						var action = new AddCell(xPos, row, startNode, endNode);

						EditorViewController.InitNewAction(action);

                        //double pad = Math.Min(CellWidth / ScalingFactor / 2, GridSpacing * .125);
                        //double x = -1;
                        //double mod = -1;
                        //bool aboveSelection = false;
						//
                        //if (end < xPos)
                        //{
                        //    x = xPos - end;
                        //    mod = x % GridSpacing;
                        //    aboveSelection = true;
                        //}
                        //else if(start > xPos)
                        //{
                        //    x = start - xPos;
                        //    mod = x % GridSpacing;
                        //}
						//
						//// see if it registers as a hit
                        //if (x >= 0 && (mod <= pad || mod >= GridSpacing - pad))
						//{
                        //    // check if it's inside the ghost zone of a rep group
                        //    int div = (int)Math.Round(x / GridSpacing);
                        //    // bpm position within row
                        //    xPos = aboveSelection ? end + div * GridSpacing : start - div * GridSpacing;
                        //    //Repeat rg = row.RepeatGroups.Where(x => x.P)
                        //    bool inGroup = false;
                        //    foreach (Repeat rg in row.RepeatGroups)
                        //    {
                        //        if (xPos < rg.Position + rg.Length) break;
						//
                        //        double range = rg.Position + rg.Length * rg.Times - pad;
                        //        if (rg.Position + rg.Length <= xPos && xPos < range)
                        //        {
                        //            inGroup = true;
                        //            break;
                        //        }
                        //    }
						//
						//	// check if inside a reference
                        //    if (!inGroup) //&& row.ReferencePositionAndDurations.Any(p => p.position <= xPos && xPos < p.position + p.duration))
                        //    {
                        //        var action = new AddCell(div, aboveSelection, xPos, row, startNode, endNode);
						//
                        //        EditorViewController.InitNewAction(action);
                        //    }
						//}
					}
				}
			}
		}

        /// <summary>
        /// Converts a position from pixels to BPM
        /// </summary>
        /// <returns>The position.</returns>
        /// <param name="value">Value.</param>
        /// <param name="row">Row.</param>
        protected double ConvertPixelsToBpm(double value, Row row)
        {
            return (value - PaddingLeft) / ScalingFactor - row.Offset;
        }

        /// <summary>
        /// Converts bpm to pixels.
        /// </summary>
        /// <returns>The bpm to pixels.</returns>
        /// <param name="value">Value.</param>
        /// <param name="row">Row.</param>
        protected double ConvertBpmToPixels(double value, Row row)
        {
            return (value + row.Offset) * ScalingFactor + PaddingLeft;
        }

        /// <summary>
        /// Draws the specific row.
        /// </summary>
        /// <param name="row">Row.</param>
        /// <param name="baseCtx">Base context.</param>
        protected void DrawRow(Row row, CGContext baseCtx)
        {
			// get rect for the CGLayer to use
			int y = GetYPositionOfRow(row);
            int x = (int)(row.Offset * ScalingFactor);
            int width = (int)(row.Duration * ScalingFactor);

            using (CGLayer layer = CGLayer.Create(baseCtx, new CGSize(width, RowHeight)))
            {
                CGContext layerCtx = layer.Context;

                // draw the background
                layerCtx.SetFillColor(RowBackgroundColor);
                layerCtx.FillRect(new CGRect(0, 0, width, RowHeight));

                // holds the Layer for each repeat group
                Stack<CGLayer> RepeatLayers = new Stack<CGLayer>();

				CGContext ctx = layerCtx;

                foreach (Cell cell in row.Cells)
                {
                    ctx = DrawElements(layerCtx, RepeatLayers, ctx, cell);
                }

                int pos = (int)(row.Offset * ScalingFactor) + PaddingLeft;
                int length = (int)(row.Duration * ScalingFactor);
                //int ypos = GetYPositionOfRow(row);

                // draw actual elements
                baseCtx.DrawLayer(layer, new CGPoint(pos, y));
                pos += length;

                // draw ghosts
                baseCtx.SetAlpha(.5f);
                while (pos < Frame.Width)
                {
                    baseCtx.DrawLayer(layer, new CGPoint(pos, y));
                    pos += length;
                }
                baseCtx.SetAlpha(1);
            }
        }

        /// <summary>
        /// Draws all the elements for a single cell. Each repeat group has it's own layer
        /// </summary>
        /// <returns>The elements.</returns>
        /// <param name="baseLayerCtx">Base Layer context.</param>
        /// <param name="RepeatLayers">Repeat layers.</param>
        /// <param name="ctx">Context.</param>
        /// <param name="cell">Cell.</param>
        protected CGContext DrawElements(CGContext baseLayerCtx, Stack<CGLayer> RepeatLayers, CGContext ctx, Cell cell)
		{
			bool cellDrawn = false;

            // handle groups in correct order
			foreach ((bool begun, AbstractGroup group) in cell.GroupActions)
			{
				// draw the cell before groups start closing.
				if (!begun && !cellDrawn)
				{
					DrawCellRect(cell, ctx);

					cellDrawn = true;
				}

				if (group.GetType() == typeof(Repeat))
				{
					if (begun)
					{
						// begin repeat group

						int w = (int)(group.Length * ScalingFactor);
						RepeatLayers.Push(CGLayer.Create(ctx, new CGSize(w, RowHeight)));

						// draw the element
						DrawGroupElement(ctx, RepeatGroupColor, group);

						ctx = RepeatLayers.Peek().Context;
					}
					else
					{
						// end repeat group

						var replyer = RepeatLayers.Pop();
						// get the context to draw on
						ctx = RepeatLayers.Any() ? RepeatLayers.Peek().Context : baseLayerCtx;
						// draw originals
						int dur = (int)(group.Length * ScalingFactor);
						int xp = (int)(group.Position * ScalingFactor);
						ctx.DrawLayer(replyer, new CGPoint(xp, 0));
						// draw copies
						ctx.SetAlpha(.4f); // repeats are faded
						for (int i = 1; i < (group as Repeat).Times; i++)
						{
							ctx.DrawLayer(replyer, new CGPoint(xp + dur * i, 0));
						}
						ctx.SetAlpha(1f);

						replyer.Dispose();
					}
				}
				else
				{
					if (begun)
					{
						// begin mult group

						DrawGroupElement(ctx, MultGroupColor, group, CellHeightPad);
					}
				}
			}

			if (!cellDrawn)
			{
				DrawCellRect(cell, ctx);
			}

			return ctx;
		}

        /// <summary>
        /// Draws the rect that represents the cell.
        /// </summary>
        /// <param name="cell">Cell.</param>
        /// <param name="ctx">Context.</param>
        protected void DrawCellRect(Cell cell, CGContext ctx)
        {
            int xPos = (int)((cell.Position - cell.RepeatGroups.Select(r => r.Position).Sum()) * ScalingFactor);

			if (!string.IsNullOrEmpty(cell.Reference))
			{
				DrawReferenceRect(cell, xPos, ctx);				
			}

			ctx.MoveTo(xPos, CellHeightPad);

			if (cell.IsSelected) ctx.SetFillColor(SelectedCellColor);
			else ctx.SetFillColor(CellColor);
			// draw the cell
			ctx.FillRect(new CGRect(xPos, CellHeightPad, CellWidth, RowHeight - 2 * CellHeightPad));
        }

        /// <summary>
        /// Draws the rectangle that signifies a layer reference.
        /// </summary>
        /// <param name="cell">Cell.</param>
        /// <param name="ctx">Context.</param>
        protected void DrawReferenceRect(Cell cell, int xPos, CGContext ctx)
        {
            var trans = new CGColor(ReferenceRectColor, cell.IsSelected ? .7f : .3f);

            CGRect rect = new CGRect(xPos, 0, cell.Duration * ScalingFactor, RowHeight);
            ctx.SetFillColor(trans);
            ctx.FillRect(rect);
        }

        /// <summary>
        /// Draws the grid lines.
        /// </summary>
        /// <param name="ctx">Context.</param>
		protected void DrawGridLines(CGContext ctx)
		{
			Row row = SelectedCells.Root.Cell.Row;

			double start = (SelectedCells.Min.Cell.Position + row.Offset) * ScalingFactor + PaddingLeft;
			double end = (SelectedCells.Max.Cell.Position + row.Offset) * ScalingFactor + PaddingLeft;
			int yPos = GetYPositionOfRow(row);

			double spacing = GridSpacing * ScalingFactor;

			start -= spacing;
			end += spacing;

			ctx.SetStrokeColor(GridLineColor);
			ctx.SetLineWidth(1);

			while (start >= 0)
			{
				int x = (int)start;
				ctx.MoveTo(x, yPos);
				ctx.AddLineToPoint(x, yPos + RowHeight);
				start -= spacing;
			}

			while (end <= Frame.Width)
			{
				int x = (int)end;
				ctx.MoveTo(x, yPos);
				ctx.AddLineToPoint(x, yPos + RowHeight);
				end += spacing;
			}

			ctx.StrokePath();
		}

        /// <summary>
        /// Draws a group box with the specified attributes.
        /// </summary>
        /// <param name="ctx">Context.</param>
        /// <param name="color">Color.</param>
        /// <param name="group">Group.</param>
        /// <param name="pad">Pad.</param>
        protected void DrawGroupElement(CGContext ctx, CGColor color, AbstractGroup group, int pad = 0)
        {
            var transp = new CGColor(color, .6f);
            var clear = new CGColor(color, 0);

			var gradient = new CGGradient(
				CGColorSpace.CreateDeviceRGB(),
				new CGColor[] { transp, clear, clear, transp },
				new nfloat[] { 0, .2f, .8f, 1 }
			);

            var start = new CGPoint(group.Position * ScalingFactor, pad);
            var end = new CGPoint(group.Position * ScalingFactor + group.Length * ScalingFactor, pad);

            ctx.SaveState();

            var rect = new CGRect(start, new CGSize(group.Length * ScalingFactor, RowHeight - pad * 2));
            ctx.AddRect(rect);

            ctx.Clip();

			ctx.DrawLinearGradient(
				gradient,
				start,
				end,
				CGGradientDrawingOptions.None
			);

            ctx.SetLineWidth(3);
            ctx.SetStrokeColor(color);
            ctx.AddRect(rect);
            ctx.StrokePath();

            ctx.RestoreState();
        }

        protected void InitSelectBox(CGPoint origin, int upperBound, int lowerBound)
        {
			SelectBoxOrigin = origin;
			SelectBox = new CAShapeLayer();
			SelectBox.LineWidth = 1;
            SelectBox.StrokeColor = SelectBoxColor;
            var fillColor = new CGColor(SelectBoxColor, .2f);
			SelectBox.FillColor = fillColor;
            SelectBoxUpperBound = upperBound;
            SelectBoxLowerBound = lowerBound;

			Layer?.AddSublayer(SelectBox);
        }

        /// <summary>
        /// Gets the Y position of a row based on it's index.
        /// </summary>
        /// <returns>The YP osition of row.</returns>
        /// <param name="row">Row.</param>
        protected int GetYPositionOfRow(Row row)
        {
            return (int)(Frame.Height - RowHeight - RowSpacing - (RowHeight + RowSpacing) * row.Index);
		}
        #endregion
    }
}
